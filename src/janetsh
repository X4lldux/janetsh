#! /usr/bin/env janet

(import shlib)
(import sh)

(var *sysrc-file* "/etc/janetsh.rc")
(var *rc-file* (string (os/getenv "HOME") "/.janetsh.rc"))
(var *hist-file* nil)
(var *script* nil)
(var *parens* false)
(var *handleopts* true)

(def- user-env (fiber/getenv (fiber/current)))

(defn- help-handler
  [&]
  (print "usage: janetsh [options] [script] [args]")
  (print
  `Options are:
  -h | --help : Show this help and exit.
  -norc : Don't load the default rc file.
  -rc path : Use an alternative rc file.
  -nosysrc : Don't load the system rc file.
  -sysrc path : Use an alternative system rc file.
  -parens : Don't add implicit parens to interactive terminal.
  -- : Stop handling options`)
  (os/exit 1)
  1)

# Option handlers
(def handlers :private
  {"-h"     help-handler
   "--help" help-handler
   "--"     (fn [&] (set *handleopts* false) 1)
   "-norc"  (fn [&] (set *rc-file* nil) 1)
   "-rc"    (fn [i &] (set *rc-file* (get process/args (+ i 1))) 2)
   "-nosysrc"  (fn [&] (set *sysrc-file* nil) 1)
   "-sysrc"    (fn [i &] (set *sysrc-file* (get process/args (+ i 1))) 2)
   "-parens" (fn [&] (set *parens* true) 1)})

(defn- dohandler [n i &]
  (def h (get handlers n))
  (if h (h i) (do (print "unknown option -" n) ((get handlers "-h")))))

# Process arguments
(var new-args @[])

(var i 2)
(def lenargs (length process/args))
(while (< i lenargs)
  (def arg (get process/args i))
  (if (and *handleopts* (= "-" (string/slice arg 0 1)))
    (+= i (dohandler arg i))
    (do
      (array/push new-args arg)
      (+= i 1)
      (when (not *script*)
         (set *script* arg)))))

(array/remove process/args 0 (length process/args))
(array/concat process/args new-args)

(var *get-prompt*
     (fn *get-prompt* [p]
       (string (sh/shrink-path (os/cwd)) " " (parser/state p :delimiters) "$ ")))

(if *script*
  (sh/init true)
  (sh/init false))

(var *get-completions*
  (fn [line start end]
    (sh/get-completions line start end user-env)))

(defn- getline [prompt buf]
  (when-let [ln (shlib/input/readline prompt *get-completions*)]
    (buffer/push-string buf ln "\n")
    buf))

(def- implicit-checker-peg
  (peg/compile '(not (* (any (set " \t\r\f\v")) (set `"(@[{`)))))

(defn- want-implicit-parens [buf p]
  (and (not *parens*)
       (> (length buf) 1)
       (empty? (parser/state p :delimiters))
       (peg/match implicit-checker-peg buf)))

(def- symchars
  "peg for valid janet symbol characters."
  '(+ (range "09" "AZ" "az" "\x80\xFF") (set "!$%&*+-./:<?=>@^_")))
  # '(+ (range "09" "AZ" "az" "\x80\xFF") (set "!$%*+-./:?=@^_")))

# Taken from https://github.com/bakpakin/mendoza/blob/master/mendoza/markup.janet
(def- janet-value
  "Grammar to detect valid janet values. Note this does not allow for a 'bare'
symbol as a value, only structs, arrays, tuples, etc."
  ~{:ws (set " \v\t\r\f\n\0")
    :readermac (set "';~,")
    :symchars ,symchars
    :token (some :symchars)
    :hex (range "09" "af" "AF")
    :escape (* "\\" (+ (set "ntrvzf0e\"\\") (* "x" :hex :hex)))
    :comment (* "#" (any (if-not (+ "\n" -1) 1)))
    :symbol (if-not (range "09") :token)
    :bytes (* (? "@") "\"" (any (+ :escape (if-not "\"" 1))) "\"")
    :long-bytes {:delim (some "`")
                 :open (capture :delim :n)
                 :close (cmt (* (not (> -1 "`")) (-> :n) ':delim) ,=)
                 :main (drop (* (? "@") :open (any (if-not :close 1)) :close))}
    :number (drop (cmt ':token ,scan-number))
    :raw-value (+ :comment :number :bytes :long-bytes
                  :ptuple :btuple :struct :symbol)
    :value (* (any (+ :ws :readermac)) :raw-value)
    :root (any :value)
    :root2 (any (* :value :value))
    :ptuple (* (? "@") "(" :root (any :ws) ")")
    :btuple (* (? "@") "[" :root (any :ws) "]")
    :struct (* (? "@") "{" :root2 (any :ws) "}")
    :main (+ :btuple :struct :ptuple)})

(defn- as-str [s]
  (let [es (->> s
                (string/replace-all "\\ " " ")
                (string/replace-all "\\" ""))]
  (string `"` es `"`)))

(defn- to-dquote [s]
  (string/replace "'" "\"" s))

(defn- escape-dquotes [s]
  (string/replace-all "\"" "\\\"" s))

(defn- add-colon [s]
  (string ":" s))

(defn- redir [fd r dst]
  (let [fd (case [fd r]
             ["" "<"] 0
             ["" ">"] 1
             ["" ">>"] 1
             (scan-number fd))]
    ~(sh/redir ,fd ,r ,dst)))

(defn- pipe []
  '(sh/build-proc))

(defn- build-proc [& args]
  (pp ['build-proc ;args])
  ~((sh/build-proc) (sh/cmd ,;args)))

(def- janetsh-grammar-old
  "Grammar to escape the non janet values with strings."
  ~{:ws (set " \v\t\r\f\n\0")
    :janet (* (drop (constant "(" )) (capture (drop ,janet-value)))
    :pipe (/ "|" ,pipe)
    :redirect (/ (* '(any (some (range "09"))) '(+ "<" ">" ">>") :token) ,redir)
    :hex (range "09" "af" "AF")
    :escape (* "\\" (+ (set "ntrvzf0e\"\\") (* "x" :hex :hex)))
    # :dquoted (capture (* "\"" (any (+ :escape (drop :ws) (if-not "\"" 1))) "\""))
    # :squoted  (* (/ (<- "'") ,to-dquote) (/ (<- (any (+ :escape (drop :ws) (if-not "'" 1)))) ,escape-dquotes) (/ (<- "'") ,to-dquote))
    :envvar (* "$" (some ,symchars))
    :token (some (+ ,symchars "\\ " "\\"))
    # :value (+ :janet :pipe :redirect :envvar :token :ws :dquoted :squoted)
    :cmd (/ (any (+ :ws '(+ :janet :token))) ,build-proc)
    :value (+ :ws :pipe :redirect :envvar :cmd)
    :main (any :value)
   })

(defmacro np [name]
  ~(fn [& xs] (pp [,name ;xs]) ;xs))

(defmacro pt [name]
  ~(fn [& xs] (pp [,name ;xs]) true))

(defn new-job [& exprs]
  ~(-> (sh/new-job) ,;exprs))

(defn build-proc []
  '(sh/build-proc))

(defn cmd [& args]
  ~(sh/cmd ,;args))

(defn eval-janet-expr [chunk]
  (def p (parser/new))
  (parser/consume p chunk)
  (parser/eof p)
  (parser/produce p))

(defn shell-expr [& expr]
  ~(-> (build-proc) ;,expr))

(defn bg []
  '(sh/background-job))

(defn def-envvar [var val]
  ~(sh/env-var ,var ,val))

(defn pipe-janet-expr [expr]
  ~(sh/pipe-janet-expr ',expr))

(def faulty-peg
  ~{
    :int (range "09")
    :ws (set " ")
    :boom (/ (some (+ :ws ':int)) ,(fn [& xs] (pp xs) xs))
    :main (some :boom)
    }
  )

# TODO: first redirects need to support &>
(def- janetsh-grammar
  "Grammar to escape the non janet values with strings."
  ~{
    # char defs
    :ws (set " \v\t\r\f")
    :wss (any :ws)
    :wsnl (set "\v\t\r\f\n")
    :hex (range "09" "af" "AF")
    :escape (* "\\" (+ (set "ntrvzf0e\"\\") (* "x" :hex :hex)))
    :symchars (+ (range "09" "AZ" "az" "\x80\xFF") (set "!%*+-./:?=@^_()"))
    :token (some (+ :symchars "\\" "\\"))


    # janet
    :escaped-janet-expr (* "$" :janet-expr)
    :janet-form (/ (* (drop (constant "(")) ',janet-value) ,eval-janet-expr)
    :janet-expr (* :wss :janet-form :wss)

    # shell
    :pipe "|"
    :redirect (/ (*
                  '(any (range "09"))
                  :wss
                  '(+ "<" ">" ">>")
                  :wss
                  ':token)
                 ,redir)
    :bg (/ "&" ,bg)

    :dquoted '(* `"` (any (+ :inject-envvar :escape (drop :ws) (if-not `"` 1))) `"`)
    :squoted '(* "'" (any (+ :escape (drop :ws) (if-not "'" 1))) "'")

    :inject-envvar (* "$" (some ,symchars))
    :def-envvar (/ (*
                    '(some (if-not "=" :symchars))
                    "="
                    '(+ :squoted :dquoted :inject-envvar :token))
                   ,def-envvar)

    :token-not-redir (if-not (*
                              (? (some (range "09")))
                              :wss
                              (+ "<" ">" ">>")
                              :token)
                       :token)
    :cmd-form (/ (some (+ :ws (<- :token-not-redir))) ,cmd)

    :shell-expr (*
                 (/ 0 ,build-proc)
                 :wss
                 (? :def-envvar)
                 (any :redirect)
                 :cmd-form
                 (any :redirect)
                 (? :bg)
                 (? (+
                     (* :wss :bg)
                     (* :wss :pipe :wss :cont-shell-expr)
                     ))
                 :wss
                 )
                 # (any (* (any :ws) :pipe :main)))
    :cont-shell-expr (+ (/ :janet-expr ,pipe-janet-expr) :shell-expr)

    :janetsh-expr (+ (some :janet-expr) (/ :shell-expr ,new-job))
    :main (* :janetsh-expr -1)
   })


(defn- escape-raw-line [line]
  "Escape the non-janet values in 'line' as strings."
  (get (peg/match janetsh-grammar line) 0))

(defn erl [line]
  "Escape the non-janet values in 'line' as strings."
  # (print (escape-raw-line line)))
  (pp (peg/match janetsh-grammar line)))

(defmacro test [l op r]
  ~(let [res (escape-raw-line ,l)]
     (if (,op res ',r)
       (print `test "` ,l `" is ok`)
       (do
         (print ` `)
         (print `test "` ,l `" is NOT ok`)
         (pp res)
         (print (string ` is not ` ',op))
         (pp ',r)
         (error (string `test "` ,l `"`)))
       )
     )
  )

(defn test-new-syntax []
  (test "echo asdf" =
        (-> (sh/new-job)
            (sh/build-proc)
            (sh/cmd "echo" "asdf")
            ))

  (test "   echo asdf  " =
        (-> (sh/new-job)
            (sh/build-proc)
            (sh/cmd "echo" "asdf")
            ))

  (test " echo asdf <x  " =
        (-> (sh/new-job)
            (sh/build-proc)
            (sh/cmd "echo" "asdf")
            (sh/redir 0 "<" "x")
            ))

  (test " echo asdf <x &" =
        (-> (sh/new-job)
            (sh/build-proc)
            (sh/cmd "echo" "asdf")
            (sh/redir 0 "<" "x")
            (sh/background-job)
            ))

  (test "<z echo asdf >x &" =
        (-> (sh/new-job)
            (sh/build-proc)
            (sh/redir 0 "<" "z")
            (sh/cmd "echo" "asdf")
            (sh/redir 1 ">" "x")
            (sh/background-job)
            ))

  (test "<z echo asdf 2>x &" =
        (-> (sh/new-job)
            (sh/build-proc)
            (sh/redir 0 "<" "z")
            (sh/cmd "echo" "asdf")
            (sh/redir 2 ">" "x")
            (sh/background-job)
            ))

  (test "echo asdf >a > s >d &" =
        (-> (sh/new-job)
            (sh/build-proc)
            (sh/cmd "echo" "asdf")
            (sh/redir 1 ">" "a")
            (sh/redir 1 ">" "s")
            (sh/redir 1 ">" "d")
            (sh/background-job)
            ))

  'ok
  )

(defn- getchunk [buf p]
  (sh/update-all-jobs-status)
  (def prompt (try (*get-prompt* p) ([e] "$ ")))
  (when (getline prompt buf)
    (when (want-implicit-parens buf p)
      (let [line (string buf)]
        (buffer/clear buf)
        (buffer/format buf "(sh/$? %s)\n" (escape-raw-line line))
        true))))

(var *show-exit-code* true)

(defn- show-status [f res added-parens]
  (case (fiber/status f)
    :dead (do
            (if (or *show-exit-code* (not added-parens))
              (pp res))
            (put user-env '_ @{:value res}))
    (debug/stacktrace f res)))

(setdyn :pretty-format "%.40p")

# convenience bindings for our user-env.
(def $$?  :macro sh/$$?)
(def $$_? :macro sh/$$_?)
(def $??  :macro sh/$??)
(def $$_  :macro sh/$$_)
(def $$   :macro sh/$$)
(def $?   :macro sh/$?)
(def $    :macro sh/$)
(def do-lines sh/do-lines)
(def out-lines sh/out-lines)

(defn- janetsh-default-repl []
  (var show-status show-status)
  (var on-compile-error bad-compile)
  (var on-parse-error bad-parse)
  (var where "<janetsh>")

  (when *hist-file*
    (try
      (shlib/input/history-load *hist-file*)
      ([e] nil)))

  # Are we done yet?
  (var going true)

  # The parser object
  (def p (parser/new))

  # Evaluate 1 source form in a protected manner
  (defn eval1 [source added-parens]
    (var good true)
    (def f
      (fiber/new
        (fn []
          (def res (compile source user-env ))
          (if (= (type res) :function)
            (res)
            (do
              (set good false)
              (def {:error err :start start :end end :fiber errf} res)
              (def msg
                (if (<= 0 start)
                  (string err " at (" start ":" end ")")
                  err))
              (on-compile-error msg errf where))))
        :a))
    (fiber/setenv f user-env)
    (def res (resume f nil))
    (when good (if going (show-status f res added-parens))))

  # Loop
  (def buf @"")
  (while going
    (buffer/clear buf)
    (let [added-parens (getchunk buf p)]
      (var pindex 0)
      (var pstatus nil)
      (def len (length buf))
      (when (= len 0)
        (parser/eof p)
        (set going false))
      (while (> len pindex)
        (+= pindex (parser/consume p buf pindex))
        (while (parser/has-more p)
          (eval1 (parser/produce p) added-parens))
        (when (= (parser/status p) :error)
          (on-parse-error p where)))))
  # Check final parser state
  (while (parser/has-more p)
    (eval1 (parser/produce p)))
  (when (= (parser/status p) :error)
    (on-parse-error p where))

  (when *hist-file*
    (shlib/input/history-save *hist-file*)))

(var *janetsh-repl* janetsh-default-repl)

(defn- run-interactive
  []
  # Load user rc file before
  (when *rc-file*
    (when (os/stat *rc-file*)
      # FIXME: filename in errors.
      (try
        (eval-string (slurp *rc-file*))
        ([e] (file/write stderr (string "error while loading " *rc-file* " : " e "\n"))))))
  (*janetsh-repl*))

(defn- run-func
  []
  (when *sysrc-file*
    (when (os/stat *sysrc-file*)
      # FIXME: filename in errors.
      (try
        (eval-string (slurp *sysrc-file*))
        ([e]
          (file/write stderr (string "error while loading " *sysrc-file* " : " e "\n"))
          (file/flush stderr)
          (when *script*
            # Don't limp along in script mode if the whole system is broken.
            (os/exit 1))))))

    (if *script*
      (import* *script* :prefix "" :exit true)
      (run-interactive)))

(def- user-fiber (fiber/new run-func :e))
(fiber/setenv user-fiber user-env)
(def- fiber-result (resume user-fiber))

# Prune jobs so less stale stuff is
# handled by our cleanup handlers.
(sh/prune-complete-jobs)

(file/flush stdout)
(file/flush stderr)

(if (= (fiber/status user-fiber) :error)
 (do
   (debug/stacktrace user-fiber fiber-result)
   (os/exit 1))
 (os/exit 0))
